
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ShiomiXマップ（管理者削除対応・完全版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: 'Segoe UI', sans-serif; background: #f4f6f8; margin: 10px; color: #333; }
    h1 { font-size: 1.8em; color: #2e7d32; text-align: center; }
    #map { width: 100%; height: 600px; margin-top: 20px; border-radius: 8px; }

    #post-panel, #cleanup-panel, #admin-panel {
      margin-top: 12px; background:#fff; border:1px solid #ddd; border-radius:8px; padding:10px;
    }
    textarea { width: 100%; min-height: 60px; font-size: 14px; }
    button { padding: 10px 16px; margin: 5px; background-color: #2e7d32; color: white; border: none; border-radius: 6px; font-size: 1em; cursor: pointer; }
    button:hover { background-color: #1b5e20; }
    .danger { background:#c62828; }
    .danger:hover { background:#8e0000; }
    .warn   { background:#ef6c00; }
    .warn:hover { background:#b24a00; }
    #status { color:#666; margin-left:6px; font-size: 0.9em; }
    .small { font-size: 12px; color:#777; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

    .color-swatch { display:inline-flex; align-items:center; gap:6px; margin-right:10px; cursor:pointer; }
    .swatch { width: 18px; height: 18px; border-radius: 50%; border: 1px solid #bbb; display:inline-block; }

    .hint { color:#555; font-size: 12px; }
    .hidden { display:none; }
  </style>
</head>
<body>

<h1>ShiomiXマップ</h1>
<div id="map"></div>

<!-- 投稿パネル -->
<div id="post-panel">
  <p>現在地（または地図中心）を使ってコメントを投稿します。</p>
  <textarea id="comment" placeholder="例：混雑少なめ／イベント開始まで10分"></textarea>

  <!-- 色選択（枠なし・淡色） -->
  <div class="row" aria-label="吹き出し色の選択">
    <span class="small">色：</span>
    <label class="color-swatch">
      <input type="radio" name="bubbleColor" value="pink" checked>
      <span class="swatch" style="background:#ffd1dc"></span>ピンク
    </label>
    <label class="color-swatch">
      <input type="radio" name="bubbleColor" value="green">
      <span class="swatch" style="background:#d7f5d1"></span>薄緑
    </label>
    <label class="color-swatch">
      <input type="radio" name="bubbleColor" value="blue">
      <span class="swatch" style="background:#d7efff"></span>水色
    </label>
    <label class="color-swatch">
      <input type="radio" name="bubbleColor" value="yellow">
      <span class="swatch" style="background:#fff2c6"></span>黄色
    </label>
    <label class="color-swatch">
      <input type="radio" name="bubbleColor" value="gray">
      <span class="swatch" style="background:#e6e6e6"></span>グレー
    </label>
  </div>

  <!-- 表示時間プリセット -->
  <div class="row">
    <label for="duration">表示時間：</label>
    <select id="duration">
      <option value="1">1時間</option>
      <option value="3">3時間</option>
      <option value="6">6時間</option>
      <option value="12">12時間</option>
      <option value="24">24時間</option>
    </select>
    <span class="hint">※現在時刻＋選択時間で表示終了を設定します</span>
  </div>

  <div class="row">
    <button id="postBtn">コメントを投稿</button>
    <span id="status"></span>
  </div>
  <p class="small">※位置が取得できない場合は地図中心座標で投稿します。</p>
</div>

<!-- 表示整理（非表示フィルタ＋本人の一括削除） -->
<div id="cleanup-panel">
  <div class="row"><strong>表示整理／削除</strong></div>
  <div class="row">
    <label><input type="checkbox" id="hideExpired" checked> 期限切れを隠す</label>
    <span class="small">（endAt を過ぎた投稿は非表示）</span>
  </div>
  <div class="row">
    <span class="small">色で隠す：</span>
    <label><input type="checkbox" class="hideColor" value="pink"> ピンク</label>
    <label><input type="checkbox" class="hideColor" value="green"> 薄緑</label>
    <label><input type="checkbox" class="hideColor" value="blue"> 水色</label>
    <label><input type="checkbox" class="hideColor" value="yellow"> 黄色</label>
    <label><input type="checkbox" class="hideColor" value="gray"> グレー</label>
    <button id="applyHide" style="margin-left:8px;">非表示を適用</button>
    <button id="clearHide">非表示解除</button>
  </div>
  <div class="row">
    <button id="bulkDeleteMine" class="danger">表示範囲の自分の投稿を一括削除</button>
  </div>
</div>

<!-- 管理者パネル（adminCheckで表示制御） -->
<div id="admin-panel" class="hidden">
  <div class="row"><strong>管理者操作</strong></div>
  <div class="row">
    <button id="bulkDeleteAllVisible" class="danger">表示範囲の投稿を全削除（所有者問わず）</button>
    <span class="small">※ deletedAt を設定（ソフト削除）</span>
  </div>
  <div class="row">
    <button id="deleteAllSoft" class="warn">全件ソフト削除（過去分含む）</button>
    <span class="small">※ シート上は残り、GETで非表示になります</span>
  </div>
  <div class="row">
    <button id="purgeAllPhysical" class="danger">全件物理削除（過去分含む・復元不可）</button>
    <span class="small">※ ヘッダ以外の行を完全削除します</span>
  </div>
</div>

<!-- LIFF SDK -->
<script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>

<script>
/** 設定 **/
const CONFIG = {
  LIFF_ID: '2008298139-lwyMjbwP',
  APPS_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbyFIrGTYWNhTw7I0u5zK-uPDrzGxH_7xXUxbS-ptxoWBWJTPeE-lu6QLSN5jt35xSc/exec',
  TTL_HOURS_TO_LOAD: 24
};

let map;
const markersById = new Map(); // id -> marker
const postsById   = new Map(); // id -> post（再描画・フィルタ・削除対象判定に利用）

// 淡色（枠なし）
const BUBBLE_COLORS = {
  pink:   '#ffd1dc',
  green:  '#d7f5d1',
  blue:   '#d7efff',
  yellow: '#fff2c6',
  gray:   '#e6e6e6'
};

const esc = s => String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
function setStatus(msg){ document.getElementById('status').textContent = msg || ''; }

// ---- LIFF 初期化＆管理者判定 ----
let currentUserId = 'guest';
let liffReady = (async function(){
  try {
    await liff.init({ liffId: CONFIG.LIFF_ID });
    if (!liff.isLoggedIn()) liff.login();
    const profile = await liff.getProfile();
    if (profile && profile.userId) currentUserId = profile.userId;
    await checkAdminAndToggleUI(currentUserId); // 管理者判定
  } catch (e) {
    console.warn('LIFF init/profile error:', e);
    // 管理者UIは非表示のまま
  }
})();
async function ensureLiff(){ try { await liffReady; } catch(e) {} }

async function checkAdminAndToggleUI(userId){
  try {
    const res = await fetch(CONFIG.APPS_SCRIPT_URL, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ action: 'adminCheck', userId })
    });
    const json = await res.json();
    if (json && json.ok && json.isAdmin) {
      document.getElementById('admin-panel').classList.remove('hidden');
    } else {
      document.getElementById('admin-panel').classList.add('hidden');
    }
  } catch(e) {
    console.warn('adminCheck failed:', e);
  }
}

// ---- 位置取得 ----
async function getCurrentLatLng(){
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) return reject(new Error('no geolocation'));
    navigator.geolocation.getCurrentPosition(
      p => resolve({ lat: p.coords.latitude, lng: p.coords.longitude }),
      err => reject(err),
      { enableHighAccuracy: true, timeout: 10000 }
    );
  });
}

// ---- 地図初期化（現在地センタリング＋青ドット） ----
async function initMap() {
  const fallback = { lat: 35.659466436461635, lng: 139.8171347921082 }; // 潮見高架下
  map = new google.maps.Map(document.getElementById("map"), { zoom: 18, center: fallback });

  try {
    const me = await getCurrentLatLng();
    map.setCenter(me);
    new google.maps.Marker({
      position: me, map,
      icon: {
        path: google.maps.SymbolPath.CIRCLE,
        fillColor: '#4285F4', fillOpacity: 0.9,
        strokeColor: '#ffffff', strokeWeight: 2, scale: 8
      },
      title: '現在地'
    });
  } catch(e) { console.warn('current position not available:', e); }

  await loadPosts();
  map.addListener('zoom_changed', redrawIconsForZoom); // ズーム連動
}
window.initMap = initMap;

// ---- 取得（GET） ----
async function loadPosts(){
  setStatus('読み込み中…');
  try {
    const res = await fetch(`${CONFIG.APPS_SCRIPT_URL}?ttlHours=${CONFIG.TTL_HOURS_TO_LOAD}`);
    const raw = await res.text();
    const json = JSON.parse(raw);
    if (!json.ok) throw new Error(json.error || 'failed');

    // クリア
    for (const m of markersById.values()) m.setMap(null);
    markersById.clear();
    postsById.clear();

    // 描画＆保持
    json.data.forEach(p => { postsById.set(p.id, p); addMarker(p); });
    setStatus(`読み込み完了（${json.data.length}件）`);
  } catch (e) {
    console.error('loadPosts error:', e);
    setStatus('読み込み失敗');
  }
}

// ---- 折返しロジック・ズームモード ----
function ellipsis(text, maxChars) { const t = text || ''; return t.length <= maxChars ? t : (t.slice(0, maxChars - 1) + '…'); }
function measureLines(text, maxCharsPerLine = 14){
  const words = (text || '').split(/\s+/);
  const lines = []; let line = '';
  for (const w of words){
    if ((line + ' ' + w).trim().length > maxCharsPerLine){
      if (line) lines.push(line);
      if (w.length > maxCharsPerLine){
        let s = 0;
        while (s < w.length){ lines.push(w.slice(s, s + maxCharsPerLine)); s += maxCharsPerLine; }
        line = '';
      } else { line = w; }
    } else { line = (line ? line + ' ' : '') + w; }
  }
  if (line) lines.push(line);
  return lines;
}
function getWrapModeByZoom(zoom){ return (zoom <= 16) ? 'single' : 'multi'; }

// ---- ★ 吹き出しSVG生成（黒枠あり／点は左下・白縁／わずかなスキマ） ----
function makeSpeechBubbleSVG(comment, colorKey, mode /* 'single' | 'multi' */){
  const bubbleColor = BUBBLE_COLORS[colorKey] || BUBBLE_COLORS.pink;
  const textRaw = esc(comment || '');
  const lines = (mode === 'single') ? [ellipsis(textRaw, 20)] : measureLines(textRaw, 14);

  // レイアウト定数
  const lineHeight = 18;
  const paddingX  = 10;
  const paddingY  = 10;
  const radius    = 12;

  const dotR      = 6;           // ドット半径
  const dotGap    = 2;           // ← 吹き出しとドットのスキマ（px）
  const dotFill   = '#333333';   // ドット塗り
  const dotStroke = '#ffffff';   // 白縁
  const dotStrokeW= 2;

  const strokeW   = 1.2;         // 吹き出し黒枠の太さ
  const strokeCol = '#000000';
  const shadowColor = 'rgba(0,0,0,0.18)';

  // 幅計算
  const longest   = Math.max(...lines.map(s => Math.max(16, s.length)));
  const charW     = (mode === 'single') ? 7.2 : 7;
  const textWidth = Math.max(16, longest) * charW;

  // 吹き出しサイズ
  const bubbleW = Math.max(60, textWidth + paddingX * 2);
  const bubbleH = lines.length * lineHeight + paddingY * 2;

  // キャンバス余白（左・下はドット半径＋スキマ分確保）
  const leftPad   = dotR + dotGap;
  const bottomPad = dotR + dotGap;

  // 吹き出しの左上
  const bubbleX = leftPad;
  const bubbleY = 0;

  // ★ ドット中心＝吹き出し左下の外側（スキマ分だけ外へ）
  const dotCX = bubbleX - dotGap;             // 左端から dotGap 外へ
  const dotCY = bubbleY + bubbleH + dotGap;   // 下端から dotGap 外へ

  // 全体サイズ
  const totalW = leftPad + bubbleW;
  const totalH = bubbleH + bottomPad;

  const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="${totalW}" height="${totalH}" viewBox="0 0 ${totalW} ${totalH}">
  <defs>
    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="1" stdDeviation="2" flood-color="${shadowColor}" flood-opacity="1"/>
    </filter>
  </defs>

  <!-- 影＋黒枠あり角丸矩形（吹き出し本体） -->
  <g filter="url(#shadow)">
    <rect x="${bubbleX}" y="${bubbleY}"
          rx="${radius}" ry="${radius}"
          width="${bubbleW}" height="${bubbleH}"
          fill="${bubbleColor}"
          stroke="${strokeCol}" stroke-width="${strokeW}" />
  </g>

  <!-- 左下の点（白縁＋塗り） -->
  <circle cx="${dotCX}" cy="${dotCY}" r="${dotR}" fill="${dotFill}" stroke="${dotStroke}" stroke-width="${dotStrokeW}" />

  <!-- テキスト -->
  <g font-family="Segoe UI, 'Hiragino Kaku Gothic ProN', 'Yu Gothic', Meiryo, sans-serif"
     font-size="14" fill="#333333">
    ${lines.map((ln, i) => {
      const tx = bubbleX + paddingX;
      const ty = paddingY + (i+1) * lineHeight - 4;
      return `<text x="${tx}" y="${ty}">${ln}</text>`;
    }).join('\n')}
  </g>
</svg>`;

  const svg64 = btoa(unescape(encodeURIComponent(svg)));
  const url = `data:image/svg+xml;base64,${svg64}`;

  // マップ座標のアンカー＝ドット中心
  return { url, totalW, totalH, anchorX: dotCX, anchorY: dotCY };
}

// ---- マーカー追加（モード適用／個別削除ボタン） ----
function addMarker(p){
  const position = { lat: p.lat, lng: p.lng };
  const mode = getWrapModeByZoom(map.getZoom() || 18);
  const { url, totalW, totalH, anchorX, anchorY } = makeSpeechBubbleSVG(p.comment || '', p.color || 'pink', mode);

  const marker = new google.maps.Marker({
    position, map,
    icon: { url, scaledSize: new google.maps.Size(totalW, totalH), anchor: new google.maps.Point(anchorX, anchorY) }
  });

  const canDelete = (currentUserId && p.userId && currentUserId === p.userId);
  const html = `
    <div>
      <div><b>${esc(p.comment || '')}</b></div>
      ${p.endAt ? `<div class="small">表示終了：${new Date(p.endAt).toLocaleString()}</div>` : ''}
      ${canDelete ? `<div style="margin-top:6px;"><button class="danger" id="delbtn-${p.id}">このコメントを削除</button></div>` : ''}
    </div>`;
  const info = new google.maps.InfoWindow({ content: html });
  marker.addListener('click', () => {
    info.open({ anchor: marker, map });
    if (canDelete) {
      google.maps.event.addListenerOnce(info, 'domready', () => {
        const btn = document.getElementById(`delbtn-${p.id}`);
        if (btn) btn.onclick = () => deletePost(p.id);
      });
    }
  });

  if (p.id) { markersById.set(p.id, marker); postsById.set(p.id, p); }
}

// ---- ズーム連動再描画（スロットリング） ----
let _zoomRedrawTimer = null;
function redrawIconsForZoom(){
  if (_zoomRedrawTimer) return;
  _zoomRedrawTimer = setTimeout(() => {
    _zoomRedrawTimer = null;
    const mode = getWrapModeByZoom(map.getZoom() || 18);
    for (const [id, post] of postsById.entries()){
      const mk = markersById.get(id); if (!mk) continue;
      const { url, totalW, totalH, anchorX, anchorY } = makeSpeechBubbleSVG(post.comment || '', post.color || 'pink', mode);
      mk.setIcon({ url, scaledSize: new google.maps.Size(totalW, totalH), anchor: new google.maps.Point(anchorX, anchorY) });
    }
  }, 80);
}

// ---- 投稿 ----
document.getElementById('postBtn').addEventListener('click', onPost);
async function onPost(){
  await ensureLiff();

  const commentEl = document.getElementById('comment');
  const durationEl = document.getElementById('duration');
  const colorKey = (document.querySelector('input[name="bubbleColor"]:checked')?.value) || 'pink';

  const comment = commentEl.value.trim();
  if (!comment) return alert('コメントを入力してください');

  const now = new Date();
  const hours = parseInt(durationEl.value, 10);
  const endAt = new Date(now.getTime() + hours * 60 * 60 * 1000);

  setStatus('投稿中…');

  let pos;
  try { pos = await getCurrentLatLng(); } catch(e) { pos = map.getCenter().toJSON(); }

  const payload = {
    action: 'create',
    userId: currentUserId, lat: pos.lat, lng: pos.lng,
    comment, color: colorKey,
    startAt: now.toISOString(), endAt: endAt.toISOString()
  };

  try {
    const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
    const json = await res.json();
    if (!json.ok) throw new Error(json.error || '投稿失敗');

    addMarker({
      id: json.id, timestamp: now.toISOString(),
      lat: pos.lat, lng: pos.lng, comment,
      color: colorKey, endAt: endAt.toISOString(),
      userId: currentUserId
    });
    commentEl.value = '';
    setStatus('投稿しました');
  } catch (e1) {
    console.warn('POST json failed, fallback to text/plain:', e1);
    try {
      const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'text/plain'}, body:JSON.stringify(payload) });
      const json = await res.json();
      if (!json.ok) throw new Error(json.error || '投稿失敗');
      addMarker({
        id: json.id, timestamp: now.toISOString(),
        lat: pos.lat, lng: pos.lng, comment,
        color: colorKey, endAt: endAt.toISOString(),
        userId: currentUserId
      });
      commentEl.value = '';
      setStatus('投稿しました');
    } catch(e2) {
      console.error('POST failed:', e2);
      alert('投稿に失敗しました。時間をおいて再度お試しください。');
      setStatus('投稿エラー');
    }
  }
}

// ---- 個別削除（本人 or 管理者） ----
async function deletePost(id){
  await ensureLiff();
  setStatus('削除中…');
  const payload = { action: 'delete', id, userId: currentUserId };

  try {
    const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
    const json = await res.json(); if (!json.ok) throw new Error(json.error || '削除失敗');
    const mk = markersById.get(id); if (mk) { mk.setMap(null); markersById.delete(id); }
    postsById.delete(id);
    setStatus('削除しました');
  } catch(e1){
    console.warn('DELETE json failed, fallback to text/plain:', e1);
    try {
      const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'text/plain'}, body:JSON.stringify(payload) });
      const json = await res.json(); if (!json.ok) throw new Error(json.error || '削除失敗');
      const mk = markersById.get(id); if (mk) { mk.setMap(null); markersById.delete(id); }
      postsById.delete(id);
      setStatus('削除しました');
    } catch(e2){
      console.error('DELETE failed:', e2);
      alert('削除に失敗しました。時間をおいて再度お試しください。');
      setStatus('削除エラー');
    }
  }
}

// ---- 非表示フィルタ（期限・色） ----
document.getElementById('applyHide').addEventListener('click', applyHideFilters);
document.getElementById('clearHide').addEventListener('click', clearHideFilters);
function applyHideFilters(){
  const hideExpired = document.getElementById('hideExpired').checked;
  const hideColors = Array.from(document.querySelectorAll('.hideColor:checked')).map(el => el.value);
  const now = Date.now();
  for (const [id, post] of postsById.entries()){
    const mk = markersById.get(id); if (!mk) continue;
    const expired = post.endAt ? (new Date(post.endAt).getTime() < now) : false;
    mk.setVisible(!( (hideExpired && expired) || hideColors.includes(post.color) ));
  }
}
function clearHideFilters(){
  for (const mk of markersById.values()) mk.setVisible(true);
  document.getElementById('hideExpired').checked = true;
  document.querySelectorAll('.hideColor').forEach(el => el.checked = false);
}

// ---- 表示範囲（viewport）に見えている投稿ID抽出 ----
function getVisiblePostIdsInViewport(){
  const bounds = map.getBounds(); if (!bounds) return [];
  const ids = [];
  for (const [id, post] of postsById.entries()){
    const pos = new google.maps.LatLng(post.lat, post.lng);
    const mk  = markersById.get(id);
    if (mk && mk.getVisible() && bounds.contains(pos)) ids.push(id);
  }
  return ids;
}

// ---- 一括削除（表示範囲の自分の投稿） ----
document.getElementById('bulkDeleteMine').addEventListener('click', async () => {
  await ensureLiff();
  const idsInView = getVisiblePostIdsInViewport()
    .filter(id => postsById.get(id)?.userId === currentUserId);

  if (idsInView.length === 0) return alert('削除対象がありません（表示範囲に自分の投稿がありません）。');
  if (!confirm(`表示範囲の自分の投稿 ${idsInView.length} 件を削除します。よろしいですか？`)) return;

  await bulkDelete(idsInView, currentUserId);
});

// ---- 管理者：表示範囲の全投稿を一括削除（所有者問わず） ----
document.getElementById('bulkDeleteAllVisible').addEventListener('click', async () => {
  await ensureLiff();
  const idsInView = getVisiblePostIdsInViewport();
  if (idsInView.length === 0) return alert('削除対象がありません（表示範囲に投稿がありません）。');
  if (!confirm(`表示範囲の投稿 ${idsInView.length} 件をすべて削除します（管理者）。よろしいですか？`)) return;
  await bulkDelete(idsInView, currentUserId); // 管理者は所有者問わずサーバで許可
});

// ---- 管理者：全件ソフト削除（過去分含む） ----
document.getElementById('deleteAllSoft').addEventListener('click', async () => {
  await ensureLiff();
  if (!confirm('全件ソフト削除（過去分含む）を実行します。よろしいですか？')) return;
  setStatus('全件ソフト削除中…');
  try {
    const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ action:'deleteAll', userId: currentUserId }) });
    const json = await res.json(); if (!json.ok) throw new Error(json.error || '全件ソフト削除失敗');
    await loadPosts(); setStatus('全件ソフト削除しました');
  } catch(e1){
    console.warn('deleteAll json failed, fallback:', e1);
    try {
      const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'text/plain'}, body:JSON.stringify({ action:'deleteAll', userId: currentUserId }) });
      const json = await res.json(); if (!json.ok) throw new Error(json.error || '全件ソフト削除失敗');
      await loadPosts(); setStatus('全件ソフト削除しました');
    } catch(e2){ console.error(e2); alert('全件ソフト削除に失敗しました'); setStatus('削除エラー'); }
  }
});

// ---- 管理者：全件物理削除（復元不可） ----
document.getElementById('purgeAllPhysical').addEventListener('click', async () => {
  await ensureLiff();
  if (!confirm('【復元不可】全件物理削除を実行します。よろしいですか？')) return;
  setStatus('全件物理削除中…');
  try {
    const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ action:'purgeAll', userId: currentUserId }) });
    const json = await res.json(); if (!json.ok) throw new Error(json.error || '全件物理削除失敗');
    await loadPosts(); setStatus('全件物理削除しました');
  } catch(e1){
    console.warn('purgeAll json failed, fallback:', e1);
    try {
      const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'text/plain'}, body:JSON.stringify({ action:'purgeAll', userId: currentUserId }) });
      const json = await res.json(); if (!json.ok) throw new Error(json.error || '全件物理削除失敗');
      await loadPosts(); setStatus('全件物理削除しました');
    } catch(e2){ console.error(e2); alert('全件物理削除に失敗しました'); setStatus('削除エラー'); }
  }
});

// ---- サーバ側 bulkDelete を呼び出す（本人 or 管理者） ----
async function bulkDelete(ids, userId){
  setStatus('一括削除中…');
  const payload = { action:'bulkDelete', ids, userId };
  try {
    const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
    const json = await res.json(); if (!json.ok) throw new Error(json.error || '一括削除失敗');
    ids.forEach(id => { const mk = markersById.get(id); if (mk) { mk.setMap(null); markersById.delete(id); } postsById.delete(id); });
    setStatus(`削除しました（${ids.length}件）`);
  } catch(e1){
    console.warn('bulkDelete json failed, fallback:', e1);
    try {
      const res = await fetch(CONFIG.APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'text/plain'}, body:JSON.stringify(payload) });
      const json = await res.json(); if (!json.ok) throw new Error(json.error || '一括削除失敗');
      ids.forEach(id => { const mk = markersById.get(id); if (mk) { mk.setMap(null); markersById.delete(id); } postsById.delete(id); });
      setStatus(`削除しました（${ids.length}件）`);
    } catch(e2){
      console.error('bulk delete failed:', e2);
      alert('一括削除に失敗しました。時間をおいて再度お試しください。');
      setStatus('削除エラー');
    }
  }
}
</script>

<!-- Google Maps API（async+defer+callback） -->
<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA4oFb8iNj2R_2lzlvpSZgOZiets5j2psg&callback=initMap"></script>
</body>
</html>
``
